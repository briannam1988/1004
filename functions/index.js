const { onRequest } = require(\"firebase-functions/v2/https\");\nconst admin = require(\"firebase-admin\");\nconst { getGenerativeModel } = require(\"firebase-admin/vertex-ai\");\nconst path = require(\"path\");\nconst fs = require(\"fs\").promises;\n\nadmin.initializeApp();\n\n// HTTP 요청을 처리하는 주 함수\nexports[\"ai-decision-analysis\"] = onRequest({ cors: true }, async (req, res) => {\n    // 정적 파일 요청인지 확인 (e.g., /index.html, /style.css)\n    if (isStaticFile(req.path)) {\n        return serveStaticFile(req.path, res);\n    }\n\n    // API 라우팅\n    switch (req.path) {\n        case \"/analyze-decision\":\n            await handleAnalyzeDecision(req, res);\n            break;\n        case \"/generate\": // 기존 문구 생성기 API\n             // 여기에 기존 문구 생성기 로직을 넣을 수 있습니다. (지금은 비워둡니다)\n             res.status(501).send(\"Not Implemented\");\n            break;\n        default:\n            // 일치하는 경로가 없으면 기본적으로 index.html을 제공 (Single Page App 동작)\n            return serveStaticFile(\"/index.html\", res);\n    }\n});\n\n// 정적 파일인지 판단하는 함수\nfunction isStaticFile(filePath) {\n    const staticFileExtensions = ['.html', '.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.svg', '.woff', '.woff2'];\n    return staticFileExtensions.includes(path.extname(filePath));\n}\n\n// 정적 파일을 읽어 클라이언트에게 제공하는 함수\nasync function serveStaticFile(filePath, res) {\n    // 보안을 위해 파일 경로 정리\n    const safePath = path.join(process.cwd(), path.normalize(filePath));\n\n    // 루트 디렉토리 밖으로 나가는 것을 방지\n    if (!safePath.startsWith(process.cwd())) {\n        res.status(403).send(\"Forbidden\");\n        return;\n    }\n\n    try {\n        const data = await fs.readFile(safePath, 'utf8');\n        const contentType = getContentType(safePath);\n        res.set('Content-Type', contentType).status(200).send(data);\n    } catch (err) {\n        console.error(`Error reading file: ${safePath}`, err);\n        if (err.code === 'ENOENT') {\n            // 파일이 없을 경우, 404 대신 index.html을 보여주어 SPA 라우팅을 돕는다.\n             const indexPath = path.join(process.cwd(), 'index.html');\n             const data = await fs.readFile(indexPath, 'utf8');\n             res.set('Content-Type', 'text/html').status(200).send(data);\n        } else {\n             res.status(500).send(\"Internal Server Error\");\n        }\n    }\n}\n\n// 파일 확장자에 따라 Content-Type을 결정하는 함수\nfunction getContentType(filePath) {\n    const ext = path.extname(filePath);\n    switch (ext) {\n        case '.html': return 'text/html';\n        case '.css': return 'text/css';\n        case '.js': return 'application/javascript';\n        case '.json': return 'application/json';\n        case '.png': return 'image/png';\n        // ... 다른 mime type들\n        default: return 'application/octet-stream';\n    }\n}\n\n\n// '/analyze-decision' API 요청을 처리하는 함수\nasync function handleAnalyzeDecision(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).send(\"Method Not Allowed\");\n    }\n\n    const { optionA, optionB, context } = req.body;\n    if (!optionA || !optionB) {\n        return res.status(400).json({ error: \"두 가지 선택지(optionA, optionB)를 모두 제공해야 합니다.\" });\n    }\n\n    const prompt = `\n        당신은 뛰어난 데이터 분석가이자, 인생 경험이 풍부한 현명한 조언자입니다. \n        사용자가 제시하는 두 가지 선택지(A와 B)와 추가 고려사항을 깊이 있게 분석하고, 어떤 선택이 더 나은지 명확하게 추천해야 합니다.\n        당신의 답변은 반드시 다음의 JSON 형식과 구조를 완벽하게 따라야 합니다. 다른 어떤 설명도 추가하지 마세요.\n\n        {\n          \"recommendation\": \"최종 추천 선택지 이름 (A 또는 B)\",\n          \"summary\": \"왜 그 선택지를 추천하는지에 대한 매력적인 한 줄 요약\",\n          \"scores\": {\n            \"optionA\": {\n              \"name\": \"선택 A의 이름\",\n              \"score\": \"선택 A에 대한 100점 만점 평가 점수 (숫자만)\"\n            },\n            \"optionB\": {\n              \"name\": \"선택 B의 이름\",\n              \"score\": \"선택 B에 대한 100점 만점 평가 점수 (숫자만)\"\n            }\n          },\n          \"comparison\": [\n            {\n              \"criteria\": \"장점 (Pros)\",\n              \"optionA\": \"선택 A의 장점들을 구체적으로 서술\",\n              \"optionB\": \"선택 B의 장점들을 구체적으로 서술\"\n            },\n            {\n              \"criteria\": \"단점 (Cons)\",\n              \"optionA\": \"선택 A의 단점들을 구체적으로 서술\",\n              \"optionB\": \"선택 B의 단점들을 구체적으로 서술\"\n            },\n            {\n              \"criteria\": \"핵심 고려사항\",\n              \"optionA\": \"선택 A를 선택할 때 반드시 생각해야 할 점\",\n              \"optionB\": \"선택 B를 선택할 때 반드시 생각해야 할 점\"\n            }\n          ],\n          \"reasoning\": \"위의 모든 분석(점수, 장단점)을 종합하여, 왜 특정 선택지를 더 추천하는지에 대한 논리적이고 상세한 설명. 사용자의 추가 고려사항을 반드시 반영하여 개인화된 조언을 제공해야 합니다.\"\n        }\n\n        --- 사용자 입력 ---\n        선택 A: ${optionA}\n        선택 B: ${optionB}\n        추가 고려사항: ${context || \"특별한 고려사항 없음\"}\n    `;\n\n    try {\n        const generativeModel = getGenerativeModel({ model: \"gemini-pro\" });\n        const result = await generativeModel.generateContent(prompt);\n        const response = await result.response;\n        \n        // AI가 생성한 텍스트에서 JSON 부분만 추출\n        const jsonString = response.text().match(/```json([\s\S]*?)```/)[1].trim();\n        const jsonData = JSON.parse(jsonString);\n\n        res.status(200).json(jsonData);\n\n    } catch (error) {\n        console.error(\"AI 생성 중 오류 발생:\", error);\n        res.status(500).json({ error: \"AI 분석 결과를 생성하는 데 실패했습니다.\" });\n    }\n}\n